#include<stdio.h>

#include "threads.h"

#include<malloc.h>


struct Semaphores
{
   struct Semaphores *prev;

   struct Semaphores *next;

   int G;

};

typedef struct Semaphores *Pointer;

   Pointer DelQ;

	 Pointer ReadyQ;

   Pointer BufferQ;

   void Init_BufferQ(void)
       {

           BufferQ=NULL;

        }

   Pointer Get(void)
   {
         Pointer TNode;

         TNode=(Pointer)malloc(sizeof(struct Semaphores));

         return(TNode);
   }


void Init_DelQ(void)
     {

         DelQ=NULL;

      }

void Init_ReadyQ(void)
		{
        ReadyQ=NULL;

         }


void AddQueues(Pointer *tem,int d)

{
         Pointer NewNode,local;

             NewNode=Get();

           NewNode->prev=NULL;

           NewNode->next=NULL;

             NewNode->G=d;

          if(*tem==NULL)

           *tem=NewNode;

           else
    {
         for(local=*tem;local->next!=NULL;local=local->next);

         local->next=NewNode;
     }
}




void Display(Pointer *tem)

{
              Pointer local;

             if(*tem==NULL)

             printf("]nQueue is empty");
else

{
              for(local=*tem;local!=NULL;local=local->next)

              printf(" %d ",local->G);
}

}

int DeleteQueues(Pointer *tem)
{
          Pointer p;

           int a;

           if(*tem==NULL)
{
           printf("\n Queue is already Empty\n");

           return(0);
}

else

{
           p=*tem;

          *tem=p->next;

           a=p->G;

           return(a);
}

}

struct semaphore

{
       int value;

         Pointer SemQ;
}Sem;


void Init_Semaphore(int a)

{

         Sem.value=a;

         Sem.SemQ=NULL;
}

int qa[1000],producingtimes[1000],consumingtimes[1000],buffer[1000];

int B,P,C,N,j=0,r,count=1;

int buf=-1,bread=-1,inum=1,pcount=1;



void PS(void)

{

            Sem.value=Sem.value-1;
}

void V(void)

{

             Sem.value=Sem.value+1;

}

void RotateQueue(Pointer *tem)
{

      AddQueues(tem,DeleteQueues(tem));

}

void Producer(void);

void Consumer(void);


int main()

{
                  int i=0;

                Init_ReadyQ();

                 Init_BufferQ();

                 Init_DelQ();

                 scanf("%d,%d,%d,%d",&B,&P,&C,&N);


                Init_Semaphore(B);

                r=(P+C)-1;

while(i<=r && qa[i]!=-1)

{

scanf("%d",&qa[i]);

AddQueues(&ReadyQ,qa[i]);

i=i+1;

}

for(i=1;i<=N;i++)

{

producingtimes[i]=0;

consumingtimes[i]=0;

}

while(ReadyQ!=NULL && count<=((P+C)*2))

{
	if(ReadyQ->G<0)

    	{

		Consumer();

    	}
	else

	{
		Producer();

	}

}

return(1);

}

void Producer(void)

{

           producingtimes[ReadyQ->G]=producingtimes[ReadyQ->G]+1;

	if(pcount==P)

	{

	               inum++;

	               pcount=0;

	}

	else

	              pcount++;

	if(Sem.value<=0)

	{

	if(producingtimes[ReadyQ->G]<=N)

{
    		printf("\n Producer %d is waiting\n",ReadyQ->G);

	      AddQueues(&Sem.SemQ,ReadyQ->G);

	      DeleteQueues(&ReadyQ);

}

   	}

	else

	{

		printf("\n Producer %d is producing item number %d\n",ReadyQ->G,producingtimes[ReadyQ->G]);


  	AddQueues(&BufferQ,ReadyQ->G);

	  PS();

	if(producingtimes[ReadyQ->G]<=N)

	RotateQueue(&ReadyQ);

	}

count++;

}

void Consumer(void)

{

consumingtimes[ReadyQ->G]=consumingtimes[ReadyQ->G]+1;

if(Sem.value==B)

{
    printf("\nConsumer %d is waiting\n",-ReadyQ->G);

       AddQueues(&DelQ,DeleteQueues(&ReadyQ));

}

else

{

printf("\nConsumer %d is consuming item generated by Producer %d\n",-ReadyQ->G,DeleteQueues(&BufferQ));

     V();
if(consumingtimes[ReadyQ->G]==N)

	AddQueues(&DelQ,DeleteQueues(&ReadyQ));

else

	RotateQueue(&ReadyQ);


}

count++;

}
